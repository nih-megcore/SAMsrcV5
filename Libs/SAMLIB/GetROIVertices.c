// GetROIVertices() -- extract ROI vertices from atlas file generated by FSnormals.py
//
//	Author:	Stephen E. Robinson
//			MEG Core Facility
//			NIMH
//

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <geoms.h>
#include <voxel.h>
#include <samlib.h>


void	GetROIVertices(
	VOXELINFO	**VertexOut,				// pointer to allocated vertices
	char		*PathName,					// full pathname of atlas file
	int			ROInum,						// ROI number (from FreeSurfer)
	int			ROIhemi,					// ROI hemisphere -- 1 == left, -1 == right
	int			*Nvert						// number of vertices in ROI
)
{
	static VOXELINFO	*Vertex;			// Vertex[N] -- array of vertices
	static VOXELINFO	*ROIvertex;			// ROIvertex[NN] -- ROI vertices
	static int			*ROIval;			// ROIval[N] -- array of ROI index values
	double				Vc[3];				// vertex coordinate
	double				Vn[3];				// vertex normal
	double				r;					// normal length
	double				r2;					// r^2
	int					NN;					// number of vertices in ROI
	int					n;					// vertex index
	int					nn;					// alternate vertex index
	int					index;				// roi index
	int					v;					// vector index
	static int			N;					// total number of entries in atlas file
	static int			once = FALSE;		// initialization flag
	size_t				size;				// number of bytes
	char				Line[256];			// line buffer
	FILE				*fp;

	// initialize -- saving entire atlas & ROI indices
	if(once == FALSE) {

		// open atlas file for read-only
		if((fp = fopen(PathName, "r")) == NULL)
			cleanup("ROI file open failed");

		// count lines
		N = 0;
		while(fgets(Line, 256, fp) != NULL)
	 		N++;
		if(N == 0)
			cleanup("empty ROI file");

		// allocate space for ROI vertex coordinates & ROI indices
		if((Vertex = (VOXELINFO *)malloc(N * sizeof(VOXELINFO))) == NULL)
			allocfailed("Vertex[]");
		if((ROIval = (int *)malloc(N * sizeof(int))) == NULL)
			allocfailed("ROIval[]");

		// reset to start of target file
		rewind(fp);

		// read vertex list
		for(n=0; n<N; n++) {
			if(fscanf(fp, "%lf%lf%lf%lf%lf%lf%d", &Vc[X_], &Vc[Y_], &Vc[Z_], &Vn[X_], &Vn[Y_], &Vn[Z_], &index) != 7)
				Cleanup("error reading vertex");

			// make unit normals
			for(v=X_, r2=0.; v<=Z_; v++)
				r2 += Vn[v] * Vn[v];
			if(r2 > 0.) {
				r = sqrt(r2);
				for(v=X_; v<=Z_; v++) {
					Vertex[n].p[v] = Vc[v];
					Vertex[n].v[v] = Vn[v] / r;
				}
				ROIval[n] = index;
			} else {
				cleanup("vertex was zero length");
			}
		}
		fclose(fp);
		once = TRUE;
	}

	// parse ROI index & hemisphere -- counting entries
	for(n=NN=0; n<N; n++)
		if(ROIval[n] == (ROInum * ROIhemi))
			NN++;

	// allocate space for ROI vertices
	size = NN * sizeof(VOXELINFO);
	if(ROIvertex == NULL) {
		if((ROIvertex = (VOXELINFO *)malloc(size)) == NULL)
			allocfailed("ROIvertex[]");
	} else {
		free((void *)ROIvertex);
		if((ROIvertex = (VOXELINFO *)malloc(size)) == NULL)
			allocfailed("ROIvertex[]");
	}

	// populate ROI vertices
	for(n=nn=0; n<N; n++)
		if(ROIval[n] == (ROInum * ROIhemi)) {
			for(v=X_; v<=Z_; v++) {
				ROIvertex[nn].p[v] = Vertex[n].p[v];
				ROIvertex[nn].v[v] = Vertex[n].v[v];
			}
			Vertex[nn].ROI = TRUE;
			Vertex[nn].Solve = FALSE;
			nn++;
		}

	// outputs
	*VertexOut = ROIvertex;
	*Nvert = NN;
}
